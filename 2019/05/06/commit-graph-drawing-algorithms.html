<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="shortcut icon" href="/media/img/favicon.png">
        <!-- SEO -->
        <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Commit graph drawing algorithms | pvigier’s blog</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="Commit graph drawing algorithms" />
<meta name="author" content="pierre" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This article is one chapter of my master thesis entitled “Design and implementation of a graphical user interface for git”. It describes the algorithm I designed to draw the commit graph in my own prototype git client called gitamine. I have adapted the content so that it fits better with this blog. Drawing graphs is a very complex topic in general but here we want to draw a specific type of graphs: commit graphs. Commit graphs have several several pieces of information that simplify the problem. The most important ones are that the graph is directed and acyclic and that the commits have timestamps. Moreover, among the many ways we can draw a directed acyclic graph some are more appropriate for commit graphs. Indeed, programmers manipulate the branches of the graph thus it will be more convenient for them if the representation allows to visualize them easily. We will first study the different types of graph drawing algorithms used in other clients. Then, we will describe how to place the nodes so that the commit graph is nicely drawable. Finally, we will cover some optimizations done in gitamine to draw and browse the graph in real time." />
<meta property="og:description" content="This article is one chapter of my master thesis entitled “Design and implementation of a graphical user interface for git”. It describes the algorithm I designed to draw the commit graph in my own prototype git client called gitamine. I have adapted the content so that it fits better with this blog. Drawing graphs is a very complex topic in general but here we want to draw a specific type of graphs: commit graphs. Commit graphs have several several pieces of information that simplify the problem. The most important ones are that the graph is directed and acyclic and that the commits have timestamps. Moreover, among the many ways we can draw a directed acyclic graph some are more appropriate for commit graphs. Indeed, programmers manipulate the branches of the graph thus it will be more convenient for them if the representation allows to visualize them easily. We will first study the different types of graph drawing algorithms used in other clients. Then, we will describe how to place the nodes so that the commit graph is nicely drawable. Finally, we will cover some optimizations done in gitamine to draw and browse the graph in real time." />
<link rel="canonical" href="https://pvigier.github.io/2019/05/06/commit-graph-drawing-algorithms.html" />
<meta property="og:url" content="https://pvigier.github.io/2019/05/06/commit-graph-drawing-algorithms.html" />
<meta property="og:site_name" content="pvigier’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-06T00:00:00+02:00" />
<script type="application/ld+json">
{"dateModified":"2019-05-06T00:00:00+02:00","datePublished":"2019-05-06T00:00:00+02:00","@type":"BlogPosting","headline":"Commit graph drawing algorithms","mainEntityOfPage":{"@type":"WebPage","@id":"https://pvigier.github.io/2019/05/06/commit-graph-drawing-algorithms.html"},"url":"https://pvigier.github.io/2019/05/06/commit-graph-drawing-algorithms.html","author":{"@type":"Person","name":"pierre"},"description":"This article is one chapter of my master thesis entitled “Design and implementation of a graphical user interface for git”. It describes the algorithm I designed to draw the commit graph in my own prototype git client called gitamine. I have adapted the content so that it fits better with this blog. Drawing graphs is a very complex topic in general but here we want to draw a specific type of graphs: commit graphs. Commit graphs have several several pieces of information that simplify the problem. The most important ones are that the graph is directed and acyclic and that the commits have timestamps. Moreover, among the many ways we can draw a directed acyclic graph some are more appropriate for commit graphs. Indeed, programmers manipulate the branches of the graph thus it will be more convenient for them if the representation allows to visualize them easily. We will first study the different types of graph drawing algorithms used in other clients. Then, we will describe how to place the nodes so that the commit graph is nicely drawable. Finally, we will cover some optimizations done in gitamine to draw and browse the graph in real time.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

        <!-- Bootstrap -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
        <!-- My themes -->
        <link href="/media/css/style.css" rel="stylesheet">
        <link href="/media/css/syntax.css" rel="stylesheet">
        <link href="/media/css/modal.css" rel="stylesheet">
        <!-- RSS -->
        <link href="https://pvigier.github.io/rss.xml" rel="alternate" title="pvigier's blog" type="application/atom+xml" />
    </head>
    <body>
        <div class="blog-masthead">
            <div class="container">
                <nav class="blog-nav">
    
        <a class="blog-nav-item" href="/">Blog</a>
    
        <a class="blog-nav-item" href="/articles/">Articles</a>
    
        <a class="blog-nav-item" href="/projects/">Projects</a>
    
        <a class="blog-nav-item" href="/about/">About</a>
    
</nav>
            </div>
        </div>
        <div class="container">
            <div class="blog-header">
                <h1 class="blog-title">pvigier's blog</h1>
                <p class="lead blog-description">computer science, programming and other ideas</p>
            </div>
            <div class="row">
                <div class="col-sm-8 blog-main">
                <div class="blog-post">
    <h2 class="blog-post-title">Commit graph drawing algorithms</h2>
    <p class="blog-post-meta">06 May 2019 by <a href="/">pierre</a></p>
    <p><img src="/media/img/commit-graph/many_merges/gitamine.png" alt="A commit graph drawn by gitamine" width="300px" class="center-image modal-image" /></p>

<p><em>This article is one chapter of my master thesis entitled “Design and implementation of a graphical user interface for git”. It describes the algorithm I designed to draw the commit graph in my own prototype git client called <a href="https://github.com/pvigier/gitamine">gitamine</a>. I have adapted the content so that it fits better with this blog.</em></p>

<p>Drawing graphs is a very complex topic in general but here we want to draw a specific type of graphs: commit graphs. Commit graphs have several several pieces of information that simplify the problem. The most important ones are that the graph is directed and acyclic and that the commits have timestamps.</p>

<p>Moreover, among the many ways we can draw a directed acyclic graph some are more appropriate for commit graphs. Indeed, programmers manipulate the branches of the graph thus it will be more convenient for them if the representation allows to visualize them easily.</p>

<p>We will first study the different types of graph drawing algorithms used in other clients. Then, we will describe how to place the nodes so that the commit graph is nicely drawable. Finally, we will cover some optimizations done in gitamine to draw and browse the graph in real time.</p>

<!--more-->

<h1 id="types-of-commit-graph-drawing-algorithms">Types of commit graph drawing algorithms</h1>

<p>To start the study of commit graph drawing, we will look at how it is done by the other git clients. The figure below shows the same portion of a <a href="https://github.com/electron/electron-api-demos">commit graph</a> displayed by different git clients. This part was chosen because there are a lot of merges and we can clearly observe the differences between the graph drawing algorithms used by all the clients.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/media/img/commit-graph/many_merges/Git_Cola.png" alt="Git Cola" width="130px" class="modal-image" /></th>
      <th style="text-align: center"><img src="/media/img/commit-graph/many_merges/GitExtensions.png" alt="Git Extensions" width="200px" class="modal-image" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Git Cola</td>
      <td style="text-align: center">Git Extensions</td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="/media/img/commit-graph/many_merges/gitk.png" alt="gitk" width="200px" class="modal-image" /></td>
      <td style="text-align: center"><img src="/media/img/commit-graph/many_merges/GitKraken.png" alt="GitKraken" width="200px" class="modal-image" /></td>
    </tr>
    <tr>
      <td style="text-align: center">gitk</td>
      <td style="text-align: center">GitKraken</td>
    </tr>
    <tr>
      <td style="text-align: center"><img src="/media/img/commit-graph/many_merges/SmartGit.png" alt="SmartGit" width="180px" class="modal-image" /></td>
      <td style="text-align: center"><img src="/media/img/commit-graph/many_merges/SourceTree.png" alt="SourceTree" width="200px" class="modal-image" /></td>
    </tr>
    <tr>
      <td style="text-align: center">SmartGit</td>
      <td style="text-align: center">SourceTree</td>
    </tr>
  </tbody>
</table>

<p>The first thing to observe is that there is no standard way to draw the commit graph. The different ways of drawing the commit graphs can be classified according to few design choices:</p>

<ul>
  <li>one or several commits on the same row;</li>
  <li>straight branches i.e. all commits of the same branch are on the same column or curved branches.</li>
</ul>

<p>We can see that Git Extensions and SmartGit seem to use a very similar algorithm with very curved branches. On the contrary, GitKraken draws branches as totally straight lines. SourceTree tries to keep branches as straight as possible but sometimes they curve. Git Cola’s algorithm has the particularity of placing several commits on the same row. The others draw the commit graph next to the commit history and thus they draw only one commit per row. Gitk draws a graph very similar to the one printed by the command <code class="highlighter-rouge">git log --graph</code>. It is much more compact than the other graphs because the commits have been reordered, the order does not follow the dates.</p>

<p>The table below sums up the characteristics of the graph drawing algorithms used by the clients.</p>

<table class="table-border">
  <thead>
    <tr>
      <th style="text-align: center">Client</th>
      <th style="text-align: center">One commit by row</th>
      <th style="text-align: center">Straight branches</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Git Cola</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">Git Extensions</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">Gitk</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">GitKraken</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: center">SmartGit</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">SourceTree</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
    </tr>
  </tbody>
</table>

<p>In gitamine, we will use an algorithm that draws only one commit by row to be able to show the commit graph and the commit history side-by-side as other git clients. Whether to draw straight or curved branches is a matter of taste. Personally, I found straight branches much more readable. Unfortunately, the only git clients that draw straight or almost straight branches, GitKraken and SourceTree, are not open-source, thus we will have to design our own algorithm.</p>

<h1 id="sorting-commits">Sorting commits</h1>

<p>In the two next sections, we will describe how to choose the position of the nodes so that the commit graph is drawable and readable. To simplify the problem, we will place the node on a 2D grid. We do not lose much in doing so because it is more pleasant to the human eye if the nodes are aligned.</p>

<p>In other words, we would like to find a function <script type="math/tex">f</script> from commits <script type="math/tex">\mathcal{C}</script> to <script type="math/tex">\mathbb{N}^2</script> which maps a commit <script type="math/tex">c</script> to its position on the grid <script type="math/tex">(i, j)</script>.</p>

<p>For the sake of simplicity, let us take the following notations for all commits <script type="math/tex">c</script> in <script type="math/tex">\mathcal{C}</script>:</p>

<ul>
  <li><script type="math/tex">c.parents</script> is the ordered list of parents of <script type="math/tex">c</script>.</li>
  <li><script type="math/tex">c.children</script> is the unordered set of children of <script type="math/tex">c</script>.</li>
  <li><script type="math/tex">c.i = f(c)_1</script> is the <script type="math/tex">i</script>-coordinate associated to <script type="math/tex">c</script> by the function <script type="math/tex">f</script>.</li>
  <li><script type="math/tex">c.j = f(c)_2</script> is the <script type="math/tex">j</script>-coordinate associated to <script type="math/tex">c</script> by the function <script type="math/tex">f</script>.</li>
</ul>

<p>As said in the previous section, we would like to draw one commit by row. But we would also like to have all the edges, which are directed following the same direction. Without loss of generality, we choose that edges should go upward that is from a row <script type="math/tex">i_1</script> to a row <script type="math/tex">i_2</script> with <script type="math/tex">i_1 > i_2</script>. To do that, we need that the parents of a commit are below this commit, namely f should respect the following condition:</p>

<script type="math/tex; mode=display">\forall c \in \mathcal{C}, \forall d \in c.parents, d.i > c.i</script>

<p>An order of commits that fulfills this condition is said to be topological.</p>

<h2 id="sorting-by-date">Sorting by date</h2>

<p>The snippet below shows the content of a commit. We can observe that it contains two different timestamps respectively <code class="highlighter-rouge">1543445903 +0100</code> and <code class="highlighter-rouge">1543522724 +0100</code>. The first one is the author date i.e. the date when the commit was created. The second is the committer date, it corresponds to the date when the commit was last modified.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree 1060af6e25ad2351db05b3ec3803b0b2f78777a0
parent 524c8211e5a68bead1d12723a5b326af49933991
author Pierre Vigier &lt;pierre.vigier@ymail.com&gt; 1543445903 +0100
committer Pierre Vigier &lt;pierre.vigier@ymail.com&gt; 1543522724 +0100

Rewrite Event, Arc and VoronoiDiagram
</code></pre></div></div>

<p>A first idea is to sort the commits by the author date. This will work for very simple repository but certain operations like <code class="highlighter-rouge">rebase</code> or <code class="highlighter-rouge">cherrypick</code> allow to put commits with older author date as children of commits with more recent author date. Hence, if we sort the commit from newest to oldest author date and set <script type="math/tex">c.i</script> to the index of <script type="math/tex">c</script> in the sorted list, we would break the topological condition.</p>

<p>The second idea is to sort the commits by committer date. This is appealing as latest modifications of the developers will be shown first. Moreover, this order should be topological in most cases as when an operation is done on a commit, its committer date is updated. Thus, when a branch with old commits, according to their author dates, is rebased, their committer dates are updated and thus they will be more recent than the committer dates of their parents.</p>

<p>However, nothing guarantees that all operations in git will satisfy this property. For instance, if commits of a repository are created on two different computers with non-synchronized clocks, problems may happen. In addition, it is possible to manually set the author date and the committer date of a commit. Thus, it is possible to attribute an older committer date to a commit than the ones of its parents. In this case, the order given by committer date will not satisfy the topological condition.</p>

<p>As a matter of fact, there exist repositories where the order according to committer dates is not a topological order. I suspect that GitKraken sorts the commits using committer date as it fails to draw correctly the graph on one of my <a href="https://github.com/pvigier/MyGAL">repository</a> as you can see in the figure below. The picture on the left shows the same repository displayed by a version of gitk modified to show the committer date in the right column instead of the author date. We can see that the commit with message “Remove useless cpp” has a committer date older than its parent.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/media/img/commit-graph/mygal/gitk.png" alt="gitk" width="250px" class="modal-image" /></th>
      <th style="text-align: center"><img src="/media/img/commit-graph/mygal/GitKraken.png" alt="GitKraken" width="250px" class="modal-image" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">gitk</td>
      <td style="text-align: center">GitKraken</td>
    </tr>
  </tbody>
</table>

<h2 id="topological-sorting">Topological sorting</h2>

<p>The standard way to obtain an ordering of nodes of a directed acyclic graph that respects the condition given above is to do a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a>.</p>

<p>The pseudo-code below is inspired from the section 22.4 of <em>Introduction to Algorithms</em>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure topological_sort(C)
    function dfs(c)
        if not c.explored
            c.explored = true
            for d in c.children
                dfs(d)
            c.i = i
            i = i + 1

    i = 0
    for c in C
        dfs(c)
</code></pre></div></div>

<p>The idea is to use depth-first search to first explore and assign the <script type="math/tex">i</script>-coordinate of all the descendants of a commit before setting the one of this commit.</p>

<p>If we use a topological sort to order the commits, we are guaranteed that the graph can be drawn with all the edges going upward. However, the algorithm does not take the dates into account. Consequently, the last updates will not necessarily be at the top of the graph and could potentially be anywhere if the topology allows it which may not be natural to programmers.</p>

<p>Moreover, there may be many valid topological orders for a commit graph and the algorithm above will output one. But as there is no assumption on the order on which the commits in <script type="math/tex">\mathcal{C}</script> will be traversed there is no guarantee that the algorithm will always output the same topological order.</p>

<h2 id="temporal-topological-sorting">Temporal topological sorting</h2>

<p>To solve the issues raised in the previous section, I slightly modified the algorithm so that the commits of <script type="math/tex">\mathcal{C}</script> are traversed according to their committer dates from newest to oldest:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure temporal_topological_sort(C)
    function dfs(c)
        if not c.explored
            c.explored = true
            for d in c.children
                dfs(d)
            c.i = i
            i = i + 1

    i = 0
    for c in C sorted from newest committer date to oldest
        dfs(c)
</code></pre></div></div>

<p>I called this algorithm temporal topological sort because it takes into account the topology of the graph and the timestamps of commits.</p>

<p>I would like to highlight the good properties of this algorithm:</p>

<ul>
  <li>It outputs a topological order of the commits.</li>
  <li>The output is guaranteed to always be the same regardless of the order of commits in <script type="math/tex">\mathcal{C}</script>.</li>
  <li>If there are no anomaly on committer dates, that is if the order induced by committer dates is already a valid topological order then the algorithm will return this order.</li>
  <li>It is blazing fast: its time complexity is <script type="math/tex">O(n\log(n) + m)</script> where <script type="math/tex">n</script> is the number of commits and <script type="math/tex">m</script> the number of edges.</li>
</ul>

<h1 id="placing-commits">Placing commits</h1>

<p>In the previous section, we have seen how to determine the <script type="math/tex">i</script>-coordinate of a commit. In other words, we have shown how to compute an order of the commits so that the edges can be drawn upward. In this section, we will see strategies to determine the <script type="math/tex">j</script>-coordinate of a commit.</p>

<p>Before getting to the heart of the matter, we must introduce some definitions that will simplify the discussion. We will separate the children of a commit in two categories: branch children and merge children.</p>

<p>A branch child is a child that continues a branch or creates a new one. While a merge child is a child that ends a branch by merging it into another one.</p>

<p>We can determine if a child is a branch child or a merge child of <script type="math/tex">c</script> by using the position of <script type="math/tex">c</script> in the list of parents of the child. The two following definitions formalize that.</p>

<p>For all <script type="math/tex">c \in \mathcal{C}</script>, branch children of <script type="math/tex">c</script> are defined by:
<script type="math/tex">c.branchChildren = \{d \in c.children\text{ s.t. }d.parents[0] = c\}</script></p>

<p>For all <script type="math/tex">c \in \mathcal{C}</script>, merge children of <script type="math/tex">c</script> are defined by:
<script type="math/tex">c.mergeChildren = \{d \in c.children\text{ s.t. }d.parents[0] \neq c\}</script></p>

<h2 id="curved-branches">Curved branches</h2>

<p>The first algorithm we will describe is a simplistic method that works well for graph drawn with curved branches.</p>

<p>The idea is to maintain a list of active branches. Initially the list is empty, then we iterate the commits one by one from the lowest <script type="math/tex">i</script>-coordinate to the largest to find its position:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure curved_branches(C)
    Initialize an empty list of active branches B
    for c in C from lowest i-coordinate to largest
        if c.branchChildren is not empty
            select d in c.branchChildren
            replace d by c in B
        else
            insert c in B
        for d' in c.branchChildren \ {d}
            remove d' from B
        c.j = index of c in B
</code></pre></div></div>

<p>Let us make few remarks on the algorithm:</p>

<ul>
  <li>A commit can only replace one of its branch children because they are the ones that extend the branch.</li>
  <li>We remove all the remaining branch children of <script type="math/tex">c</script> since they could only be replaced by <script type="math/tex">c</script>, which is their first parent, but <script type="math/tex">c</script> replaces another commit.</li>
</ul>

<p>The git clients that draw graphs with curved branches should use a very similar algorithm. However, there are two points that are still ambiguous:</p>

<ul>
  <li>A commit may have several branch children. A strategy is to select the leftmost one i.e. the one with lowest <script type="math/tex">j</script>-coordinate.</li>
  <li>We do not precise where to insert <script type="math/tex">c</script> in the list of active branches. The simplest solution is to append.</li>
</ul>

<p>We do not give more details for this version as we will do for the one with straight branches.</p>

<h2 id="straight-branches">Straight branches</h2>

<p>In this section, we will describe an algorithm to draw the commit graph with straight branches i.e. with all the commits of a same branch on the same column. The advantage of this design is that it is easier to visualize branches which are a core concept of git.</p>

<h3 id="types-of-edges">Types of edges</h3>

<p>Firstly, let us make a distinction between two types of edges that will be represented differently as depicted in the figure below:</p>

<ul>
  <li>edges between a commit and one of its branch children;</li>
  <li>edges between a commit and one of its merge children.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/media/img/commit-graph/design_straight_branches/first_parent.svg" alt="Edge to branch children" class="modal-image" /></th>
      <th style="text-align: center"><img src="/media/img/commit-graph/design_straight_branches/other_parent.svg" alt="Edges to merge children" class="modal-image" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><a href="https://github.com/electron/electron-api-demos">Edge to branch children</a></td>
      <td style="text-align: center"><a href="https://github.com/pvigier/MyGAL">Edge to merge children</a></td>
    </tr>
  </tbody>
</table>

<h3 id="algorithm">Algorithm</h3>

<p>Secondly, let us describe a pseudo-code of the algorithm used to determine the <script type="math/tex">j</script>-coordinate of commits:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure straight_branches(C)
    Initialize an empty list of active branches B
    for c in C from lowest i-coordinate to largest
        compute forbidden j-coordinates J(c)
        if {d in c.branchChildren s.t. d.j is not it J(c)} is not empty
            select d in {d in c.branchChildren s.t. d.j is not in J(c)}
            replace d by c in B
        else
            insert c in B
        for d' in c.branchChildren \ {d}
            B[d'.j] = nil
        c.j = index of c in B
</code></pre></div></div>

<p>The algorithm looks quite similar to the one described in the previous section as both used a list of active branches. However, the key difference are:</p>

<ul>
  <li>We compute a set of forbidden columns. These columns correspond to <script type="math/tex">j</script>-coordinates where if we place <script type="math/tex">c</script> there then there will be problem to link <script type="math/tex">c</script> with some of its children. The edges would overlap other commits or branches. We will detail how to define and compute <script type="math/tex">J(c)</script> later.</li>
  <li>We can insert <script type="math/tex">c</script> at an index of <script type="math/tex">B</script> equals to <code class="highlighter-rouge">nil</code> if one is available, otherwise we append.</li>
  <li>Instead of removing an element from <script type="math/tex">B</script>, we just set its index to <code class="highlighter-rouge">nil</code>.</li>
</ul>

<p>Previously, in algorithm <code class="highlighter-rouge">curved_branches</code>, we could remove a branch from the list of active branches or insert one in the middle of it which would shift branches respectively to the left or to the right all the branches to the left of the removed branch. Now, we remove a branch by setting its index to <code class="highlighter-rouge">nil</code> and we can only append branches. These operations cause no shift of other branches and that is the reason why the branches are straight.</p>

<h3 id="forbidden-indices">Forbidden indices</h3>

<p>We will now see how to determine and compute the set of forbidden indices <script type="math/tex">J(c)</script> for a commit <script type="math/tex">c</script>. To do that, we will take a look at the example below.</p>

<p><img src="/media/img/commit-graph/constraints/constraints_before.svg" alt="Before processing g" class="center-image modal-image" /></p>

<p>We would like to compute the <script type="math/tex">j</script>-coordinate of the commit <script type="math/tex">g</script> which is the second parent of <script type="math/tex">b</script>. So we need to draw an edge between a parent and a merge child. The list of active branches <script type="math/tex">B</script> is equal to <script type="math/tex">[f, nil, b, nil, c]</script>. We could insert at index <script type="math/tex">1</script> and <script type="math/tex">3</script> as these indices are equal to <code class="highlighter-rouge">nil</code> or append.</p>

<p>Let us examine the three cases:</p>

<ul>
  <li>Index <script type="math/tex">1</script>: the edge from <script type="math/tex">g</script> to <script type="math/tex">b</script> would overlap the commit <script type="math/tex">e</script>.</li>
  <li>Index <script type="math/tex">3</script>: the edge from <script type="math/tex">g</script> to <script type="math/tex">b</script> would overlap the edge from <script type="math/tex">c</script> to <script type="math/tex">b</script>.</li>
  <li>Append: this index has never been used (as otherwise, it would be equal to <code class="highlighter-rouge">nil</code>) so there cannot be any overlap.</li>
</ul>

<p>Thus the right choice is to append <script type="math/tex">g</script> to <script type="math/tex">B</script>, this results in the graph shown in the figure below.</p>

<p><img src="/media/img/commit-graph/constraints/constraints_after.svg" alt="After processing g" class="center-image modal-image" /></p>

<p>We have shown that we must be careful when we process a commit that has merge children. In particular, we must be sure that there is no obstacle that prevents from linking the commit to one of its merge children.</p>

<p>For a branch child, there is no such problem because the edge follows the same column as the one on which the child is. And there is no obstacle in this case since the child is present in the list of active branches and prevent other commits or edges from occupying this column.</p>

<p>Thus, we can now give a definition for the set <script type="math/tex">J(c)</script>:</p>

<script type="math/tex; mode=display">J(c) = \underset{d \in c.mergeChildren}{\cup}{\{j \text{ s.t. the column j is non-empty between rows }d.i\text{ and }c.i\}}</script>

<p>In layman terms, <script type="math/tex">J(c)</script> is the set of indices of columns where if <script type="math/tex">c</script> would be placed there, it would be impossible to link it with one of its children.</p>

<p>We can simplify the expression of <script type="math/tex">J(c)</script> thanks to the following lemma.</p>

<p><em>Lemma</em>:
<script type="math/tex">J(c) = \{j \text{ s.t. the column j is non-empty between rows }\underset{d \in c.mergeChildren}{\min}{d.i}\text{ and }c.i\}</script></p>

<p><a href="#proof1" data-toggle="collapse">Show the proof</a></p>
<div id="proof1" class="collapse">

<p>Let \(J_i(c)\) be equal to \(\{j \text{ s.t. the column j is non-empty between rows }i\text{ and }c.i\}\) for all \(i\). Then:</p>

\[
J(c) = \underset{d \in c.mergeChildren}{\cup}{J_{d.i}(c)}
\]

<p>But if \(i' &lt; i\) then \(J_i \subseteq J_{i'}\). So:</p>

\[
J(c) = J_{i_{min}}(c)\text{ with }i_{min} = \underset{c.mergeChildren}{\min}{d.i}
\]
<hr />
</div>

<p>I developed two methods to compute <script type="math/tex">J(c)</script> quickly.</p>

<p>In the first one, we maintain the list of <script type="math/tex">J_i(c)</script> for all commits that still have parents. Then when we want to compute <script type="math/tex">J(c)</script> for a commit <script type="math/tex">c</script>, we just have to compute <script type="math/tex">i_{min}</script> and to retrieve <script type="math/tex">J_{i_{min}}(c)</script> which is equal to <script type="math/tex">J(c)</script> according to the previous lemma.</p>

<p>The second method uses an <a href="https://en.wikipedia.org/wiki/Interval_tree">interval tree</a> as described in section 14.3 of <em>Introduction to Algorithms</em> which is a data structure that allows to quickly find all intervals that intersect a given interval. The idea, here, is to add an interval of rows with the column as associated data in the interval tree each time we add a commit or an edge. Then when we want to find the occupied columns between <script type="math/tex">i_{min}</script> and <script type="math/tex">c.i</script>, we just have to query the intervals that overlap with <script type="math/tex">[i_{min}, c.i]</script>.</p>

<p>Both methods were implemented and benchmarked on a <a href="https://github.com/facebook/react">large repository</a> to see which is the most efficient. The table below presents the result of this benchmark.</p>

<table class="table-border">
  <thead>
    <tr>
      <th style="text-align: center">Method</th>
      <th style="text-align: center">Mean (ms)</th>
      <th style="text-align: center">Standard deviation (ms)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">List of <script type="math/tex">J_i(c)</script></td>
      <td style="text-align: center">274</td>
      <td style="text-align: center">59.0</td>
    </tr>
    <tr>
      <td style="text-align: center">Interval tree</td>
      <td style="text-align: center">482</td>
      <td style="text-align: center">27.9</td>
    </tr>
  </tbody>
</table>

<p>The mean and standard deviation are computed on 10 measures. We can see that the first method is faster. It is the one currently used by gitamine.</p>

<p>Finally, here are some examples of commit graphs drawn by gitamine:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/media/img/commit-graph/many_merges/gitamine.png" alt="electron-api-demos" width="250px" class="modal-image" /></th>
      <th style="text-align: center"><img src="/media/img/commit-graph/mygal/gitamine.png" alt="MyGAL" width="250px" class="modal-image" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><a href="https://github.com/electron/electron-api-demos">Electron API Demos</a></td>
      <td style="text-align: center"><a href="https://github.com/pvigier/MyGAL">MyGAL</a></td>
    </tr>
  </tbody>
</table>

<h1 id="optimizations">Optimizations</h1>

<p>In the previous sections, we have shown how to compute the positions of each commits so that the graph is nicely drawable. In this section, we will discuss how to draw it effectively.</p>

<p>The first naive implementation allocates a canvas sufficiently large to draw the whole graph and draws it only once. However, for large repositories the canvas could be very large and use a lot of memory. The memory usage is in <script type="math/tex">O(n \times w)</script> where <script type="math/tex">n</script> is the number of commits and <script type="math/tex">w</script> is the width of the graph i.e the number of columns used. Thus, this implementation does not scale well in term of memory. Moreover, HTML canvasses are often implemented using GPU rendering and video memory is scarcer than main memory. In addition, Chromium seems to not manage well such big canvas. Indeed when scrolling, the application suffers important slowdowns.</p>

<p>Thus, the next step was to only allocate a canvas as large as the visible area. This method does not suffer from the problem described previously. However, we need to redraw each time the user scrolls or resizes the windows as the visible part of the graph changes.</p>

<p>To speed up the rendering, we need to render only what is actually visible. Finding the nodes that are visible is easy and can be done in constant time. We just have to find the first and the last commits visible by doing integer divisions of the top and bottom coordinates of the visible area by the height of a row.</p>

<p>However, determining the edges that are visible is more difficult. Indeed, edges that are linked to a visible commit are visible, but there may be edges that connect commits on both sides of the visible area as depicted in the figure below.</p>

<p><img src="/media/img/commit-graph/edges_visible/edges_visible.svg" alt="Edges visible" class="center-image modal-image" /></p>

<p>To find them quickly, we must recognize that this is a problem of finding intersecting intervals again. Indeed, we can represent all the edges by intervals of rows and the visible area is also an interval of rows. An edge is visible if and only if its interval overlaps with the interval of the visible area. So we can use an interval tree to find all the visible edges in <script type="math/tex">O(k\log{m})</script> where <script type="math/tex">m</script> is the number edges and <script type="math/tex">k</script> the number of edges that are visible.</p>

<p>In the table below, we can observe the time it takes to render the visible part of a large commit graph with and without the different optimizations we talked about:</p>

<table class="table-border">
  <thead>
    <tr>
      <th style="text-align: center">Method</th>
      <th style="text-align: center">Mean (ms)</th>
      <th style="text-align: center">Standard deviation (ms)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">All nodes and all edges</td>
      <td style="text-align: center">106</td>
      <td style="text-align: center">7.42</td>
    </tr>
    <tr>
      <td style="text-align: center">Only visible commits but all edges</td>
      <td style="text-align: center">26.8</td>
      <td style="text-align: center">3.37</td>
    </tr>
    <tr>
      <td style="text-align: center">Only visible commits and edges</td>
      <td style="text-align: center">0.580</td>
      <td style="text-align: center">0.606</td>
    </tr>
  </tbody>
</table>

<p>The mean and the standard deviation are computed over 100 measures.</p>

<p>The last optimization does not concern the graph rendering but the commit list which is displayed next to the graph. Displaying the whole list of commits does not scale well when there are thousands or tens of thousands commits. Thus, we can apply the same idea as previously and only display the commits that are visible. However, to give the impression to the user that all the commits are displayed and give him the ability to scroll, padding was added before and after the displayed items.</p>

    <p><em>If you are interested in my adventures during the development of Vagabond, you can follow me on <a href="https://twitter.com/PierreVigier">Twitter</a>.</em></p>
    
	<p>Tags: <span class="label label-primary"><a href="/tag/graph">graph</a></span> <span class="label label-primary"><a href="/tag/git">git</a></span> </p>
	
</div><!-- /.blog-post -->
<hr/>
<p>Subscribe to the newsletter if you do not want to miss any new article:</p>
<!-- Begin Mailchimp Signup Form -->
<link href="//cdn-images.mailchimp.com/embedcode/horizontal-slim-10_7.css" rel="stylesheet" type="text/css">
<style type="text/css">
	#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; width:100%;}
	/* Add your own Mailchimp form style overrides in your site stylesheet or in this style block.
	   We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
</style>
<div id="mc_embed_signup">
<form action="https://ymail.us20.list-manage.com/subscribe/post?u=7bb3b720a12ef1d8e0b48d8da&amp;id=7516dd4562" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">

	<input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_7bb3b720a12ef1d8e0b48d8da_7516dd4562" tabindex="-1" value=""></div>
    <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>
<!--End mc_embed_signup-->
<!-- Disqus -->
<hr/>
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://pvigier-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                </div>
                <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
	<div class="sidebar-module">
        <h4>Tags</h4>
        <ol class="list-unstyled">
		
			<li><a href="/tag/math">math (3)</a></li>
		
			<li><a href="/tag/python">python (6)</a></li>
		
			<li><a href="/tag/cpp">cpp (8)</a></li>
		
			<li><a href="/tag/pcg">pcg (13)</a></li>
		
			<li><a href="/tag/simulopolis">simulopolis (5)</a></li>
		
			<li><a href="/tag/linux">linux (1)</a></li>
		
			<li><a href="/tag/geometry">geometry (1)</a></li>
		
			<li><a href="/tag/graph">graph (1)</a></li>
		
			<li><a href="/tag/git">git (1)</a></li>
		
			<li><a href="/tag/vagabond">vagabond (23)</a></li>
		
			<li><a href="/tag/ecs">ecs (2)</a></li>
		
			<li><a href="/tag/game-engine">game-engine (8)</a></li>
		
        </ol>
    </div>
    <div class="sidebar-module">
        <h4>Archives</h4>
        <ol class="list-unstyled">
		
        
            
            
            
            
			<li id="yMarch 2020"><a href="/2020/03">March 2020 (1)</a></li>
				
            
        
            
            
            
            
			<li id="yFebruary 2020"><a href="/2020/02">February 2020 (1)</a></li>
				
            
        
            
            
            
            
			<li id="yNovember 2019"><a href="/2019/11">November 2019 (1)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
			<li id="yOctober 2019"><a href="/2019/10">October 2019 (2)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
			<li id="ySeptember 2019"><a href="/2019/09">September 2019 (2)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
			<li id="yAugust 2019"><a href="/2019/08">August 2019 (4)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
			<li id="yJuly 2019"><a href="/2019/07">July 2019 (5)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
			<li id="yJune 2019"><a href="/2019/06">June 2019 (4)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
			<li id="yMay 2019"><a href="/2019/05">May 2019 (5)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
			<li id="yNovember 2018"><a href="/2018/11">November 2018 (3)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
			<li id="yOctober 2018"><a href="/2018/10">October 2018 (3)</a></li>
				
            
        
            
            
            
            
			<li id="yJune 2018"><a href="/2018/06">June 2018 (1)</a></li>
				
            
        
            
            
            
            
			<li id="yMay 2018"><a href="/2018/05">May 2018 (1)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
			<li id="yFebruary 2018"><a href="/2018/02">February 2018 (2)</a></li>
				
            
        
            
            
            
            
			<li id="yAugust 2017"><a href="/2017/08">August 2017 (1)</a></li>
				
            
        
            
            
            
            
			<li id="yJuly 2017"><a href="/2017/07">July 2017 (1)</a></li>
				
            
        
            
            
            
            
			<li id="yFebruary 2017"><a href="/2017/02">February 2017 (1)</a></li>
				
            
        
        </ol>
    </div>
    <div class="sidebar-module">
        <h4>Follow me</h4>
        <ol class="list-unstyled">
            <li><a href="https://github.com/pvigier">GitHub</a></li>
            <li><a href="https://pvigier.itch.io/">itch.io</a></li>
            <li><a href="https://twitter.com/PierreVigier">Twitter</a></li>
            <li><a href="/rss.xml">RSS</a></li>
        </ol>
    </div>
    <div class="sidebar-module">
        <a class="twitter-timeline" data-height="400" href="https://twitter.com/PierreVigier?ref_src=twsrc%5Etfw">Tweets by PierreVigier</a> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    </div>
</div><!-- /.blog-sidebar -->

            </div><!-- /.row -->
        </div><!-- /.container -->

        <footer class="blog-footer">
            <p>Powered by <a href="http://getbootstrap.com">Bootstrap</a> and <a href="http://jekyllrb.com">Jekyll</a>.</p>
            <p>
                <a href="#">Back to top</a>
            </p>
        </footer>
        <!-- Javascript -->
        <!-- jQuery -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
        <!-- Bootstrap -->
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
        <!-- MathJax -->
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
        <!-- Analytics -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-30902264-4', 'auto');
        ga('send', 'pageview');
        </script>
        <!-- Modal images -->
        <script src="/media/js/modal.js"></script>
    </body>
</html>
