<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="Pierre Vigier">

        <title>Fractal Image Compression - pvigier's blog</title>
        <link rel="shortcut icon" href="/media/img/favicon.png">
        <!-- Bootstrap -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
        <!-- My themes -->
        <link href="/media/css/style.css" rel="stylesheet">
        <link href="/media/css/syntax.css" rel="stylesheet">
        <link href="/media/css/modal.css" rel="stylesheet">
    </head>
    <body>
        <div class="blog-masthead">
            <div class="container">
                <nav class="blog-nav">
                    <a class="blog-nav-item active" href="/">Blog</a>
                    <a class="blog-nav-item" href="/articles">Articles</a>
                    <a class="blog-nav-item" href="/projects">Projects</a>
                    <!--<a class="blog-nav-item" href="/best-resources">Best Resources</a>-->
                    <a class="blog-nav-item" href="/resume">Resume</a>
                    <a class="blog-nav-item" href="/about">About</a>
                </nav>
            </div>
        </div>
        <div class="container">
            <div class="blog-header">
                <h1 class="blog-title">pvigier's blog</h1>
                <p class="lead blog-description">computer science, programming and other ideas</p>
            </div>
            <div class="row">
            <div class="col-sm-8 blog-main">
<div class="blog-post">
    <h2 class="blog-post-title">Fractal Image Compression</h2>
    <p class="blog-post-meta">14 May 2018 by <a href="/">pierre</a></p>
    <p>One year ago, I coded a very simple implementation of fractal image compression for a course and I made the code available on github <a href="https://github.com/pvigier/fractal-image-compression">there</a>.</p>

<p>To my surprise, the repo is quite popular. So I decided to update the code and to write an article to explain the theory and the code.</p>

<!--more-->

<h1 id="theory">Theory</h1>

<p>This part is quite technical, you can skip it if you are only interested by a documentation of the code.</p>

<h2 id="contractions">Contractions</h2>

<p>Let <script type="math/tex">(E, d)</script> be a <a href="https://en.wikipedia.org/wiki/Complete_metric_space">complete metric space</a> and <script type="math/tex">f : E \rightarrow E</script> a mapping from <script type="math/tex">E</script> to <script type="math/tex">E</script>.</p>

<p>We will say that <script type="math/tex">f</script> is a <a href="https://en.wikipedia.org/wiki/Contraction_mapping">contraction</a> if there exists <script type="math/tex">% <![CDATA[
0 < s < 1 %]]></script> such that:</p>

<script type="math/tex; mode=display">\forall x, y \in E, d(f(x), f(y)) \leq sd(x, y)</script>

<p>From here, <script type="math/tex">f</script> will denote a contraction with contractivity factor <script type="math/tex">s</script>.</p>

<p>There are two important theorems on contractions: the <a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem">Contraction Mapping Theorem</a> and the <a href="https://en.wikipedia.org/wiki/Collage_theorem">Collage Theorem</a>.</p>

<p><em>Theorem (Contraction Mapping Theorem)</em>: <script type="math/tex">f</script> has an unique fixed point <script type="math/tex">x_0</script>.</p>

<p><a href="#proof1" data-toggle="collapse">Show the proof</a></p>
<div id="proof1" class="collapse">
<p>First, let us proof that the sequence \((u_n)\) defined by \(\left\{\begin{alignat*}{2}u_0 &amp; = x\\ u_{n+1} &amp; = f(u_n)\end{alignat*}\right.\) is convergent for all \(x \in E\).</p>

<p>For all \(m &lt; n \in \mathbb{N}\): </p>

$$
\begin{alignat*}{2}
d(u_m, u_n) &amp; = d(f^m(x), f^n(x)) \\
            &amp; \leq s^md(x, f^{n-m}(x)) \text{ because } f \text{ is a contraction} \\
            &amp; \leq s^m\left(\sum_{i=0}^{n-m-1}{d(f^i(x), f^{i+1}(x))}\right) \text{ by the triangular inequality}  \\
            &amp; \leq s^m\left(\sum_{i=0}^{n-m-1}{s^id(x, f(x))}\right) \text{ because } f \text{ is a contraction}  \\
            &amp; = s^m\left(\frac{1 - s^{n-m}}{1 - s}d(x, f(x))\right) \\
            &amp; \leq \frac{s^m}{1 - s}d(x, f(x)) \underset{m \rightarrow \infty}{\rightarrow} 0
\end{alignat*}
$$

<p>So \((u_n)\) is a <a href="https://en.wikipedia.org/wiki/Cauchy_sequence">Cauchy sequence</a> and as \(E\) is complete, \((u_n)\) is convergent. Let \(x_0\) bet its limit.</p>

<p>Moreover, as a contraction is <a href="https://en.wikipedia.org/wiki/Lipschitz_continuity">Lipschitz-continuous</a>, it is also continuous so \(f(u_n) \rightarrow f(x_0)\). Thus, if we let \(n\) tend to infinity in \(u_{n+1} = f(u_n)\), we have that \(x_0 = f(x_0)\). So \(x_0\) is a fixed point of \(f\).</p>

<p>We have shown that  \(f\) has a fixed point. Let us show by contradiction that it is unique. Let \(y_0\) be another fixed point, then:</p>

$$
d(x_0, y_0) = d(f(x_0), f(y_0)) \leq sd(x_0, y_0) &lt; d(x_0, y_0)
$$

<p>Contradiction.</p>

<hr />
</div>

<p>From here, <script type="math/tex">x_0</script> will denote the fixed point of <script type="math/tex">f</script>.</p>

<p><em>Theorem (Collage Theorem)</em>: If <script type="math/tex">% <![CDATA[
d(x, f(x)) < \epsilon %]]></script> then <script type="math/tex">% <![CDATA[
d(x, x_0) < \frac{\epsilon}{1 - s} %]]></script>.</p>

<p><a href="#proof2" data-toggle="collapse">Show the proof</a></p>
<div id="proof2" class="collapse">
<p>We showed in the previous proof that \(d(u_m, u_n) \leq \frac{s^m}{1 - s}d(x, f(x)) = \frac{s^m}{1 - s}\epsilon\).</p>

<p>If we fix \(m\) to \(0\) then we have that \(d(x, u_n) \leq \frac{\epsilon}{1 - s}\).</p> 

<p>Finally we let \(n\) tend to infinity to obtain the desired result.</p>

<hr />
</div>

<p>The second theorem tells us that if we find a contraction <script type="math/tex">f</script> such that <script type="math/tex">f(x)</script> is near to <script type="math/tex">x</script> then we are sure that the fixed point of <script type="math/tex">f</script> is also near to <script type="math/tex">x</script>.</p>

<p>This result will be fundamental in the following. Indeed instead of saving an image, we will only save a contraction whose fixed point is near to the image.</p>

<h2 id="contractions-for-images">Contractions for images</h2>

<p>In this part, we will show how to build a contraction such that its fixed point is near to a given image.</p>

<p>Firstly, let us define the image set and a distance. We choose <script type="math/tex">E = [0, 1]^{h \times w}</script>. <script type="math/tex">E</script> is the set of matrices with <script type="math/tex">h</script> rows, <script type="math/tex">w</script> columns and with coefficients in <script type="math/tex">[0, 1]</script>. Then we take <script type="math/tex">d(x, y) = \left(\sum_{i=1}^{h}{\sum_{j=1}^{w}{(x_{ij}-y_{ij})^2}}\right)^{0.5}</script>. <script type="math/tex">d</script> is the distance obtained from the <a href="https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm">Frobenius norm</a>.</p>

<p>Now, let <script type="math/tex">x \in E</script> the image we want to compress.</p>

<p>We will segment twice the image in blocks:</p>

<ul>
  <li>Firstly, we partition the image in <em>destination</em> or <em>range</em> blocks <script type="math/tex">R_1, ..., R_L</script>. These blocks are disjoint and they cover the whole image.</li>
  <li>Then, we segment the image in <em>source</em> or <em>domain</em> blocks <script type="math/tex">D_1, ..., D_K</script>. These blocks are not necessarily disjoint and neither they necessarily cover the image.</li>
</ul>

<p>For instance, we can segment the image like this:</p>

<p><img src="/media/img/fractal/segmentation.png" alt="Example of segmentation" class="center-image modal-image" /></p>

<p>Then, for each range block <script type="math/tex">R_l</script>, we will choose a domain block <script type="math/tex">D_{k_l}</script> and a mapping <script type="math/tex">f_l : [0, 1]^{D_{k_l}} \rightarrow [0, 1]^{R_{l}}</script>.</p>

<p>Finally, we can define our function <script type="math/tex">f</script> as:</p>

<script type="math/tex; mode=display">f(x)_{ij} = f_l(x_{D_{k_l}})_{ij} \text{ if } (i, j) \in R_l</script>

<p><em>Claim</em>: If all <script type="math/tex">f_l</script> are contractions then <script type="math/tex">f</script> is a contraction.</p>

<p><a href="#proof3" data-toggle="collapse">Show the proof</a></p>
<div id="proof3" class="collapse">
<p>Let \(x, y \in E\) and suppose that all \(f_l\) are contractions with contractivity factor \(s_l\). Then we have that:</p>

$$
\begin{alignat*}{2}
d(f(x), f(y))^2 &amp; = \sum_{i=1}^{h}{\sum_{j=1}^{w}{(f(x)_{ij}-f(y)_{ij})^2}} \text{ by definition of } d \\
&amp; = \sum_{l=1}^L{\sum_{(i,j) \in R_l}{(f(x)_{ij}-f(y)_{ij})^2}} \text{ because } (R_l) \text{ is a partition} \\
&amp; = \sum_{l=1}^L{\sum_{(i,j) \in R_l}{(f_l(x_{D_{k_l}})_{ij}-f_l(y_{D_{k_l}})_{ij})^2}} \text{ by definition of } f \\
&amp; = \sum_{l=1}^L{d(f_l(x_{D_{k_l}}), f_l(y_{D_{k_l}}))^2} \text{ by definition of } d \\
&amp; \leq \sum_{l=1}^L{s_l^2d(x_{D_{k_l}}, y_{D_{k_l}})^2} \text{ because the } (f_l) \text{ are contractions} \\
&amp; \leq \underset{l}{\max}{s_l^2}\sum_{l=1}^L{d(x_{D_{k_l}}, y_{D_{k_l}})^2} \\
&amp; = \underset{l}{\max}{s_l^2}\sum_{l=1}^L{\sum_{(i,j) \in R_l}{(x_{ij}-y_{ij})^2}} \text{ by definition of } d \\
&amp; = \underset{l}{\max}{s_l^2}\sum_{i=1}^{h}{\sum_{j=1}^{w}{(x_{ij}-y_{ij})^2}} \text{ because } (R_l) \text{ is a partition} \\
&amp; = \underset{l}{\max}{s_l^2}d(x, y)^2 \text{ by definition of } d \\
\end{alignat*}
$$

<hr />
</div>

<p>It remains one question to answer to: How to choose <script type="math/tex">D_{k_l}</script> and <script type="math/tex">f_l</script>?</p>

<p>The Collage Theorem suggests us a way to choose them: if <script type="math/tex">x_{R_l}</script> is near to <script type="math/tex">f(x_{D_{k_l}})</script> for all <script type="math/tex">l</script> then <script type="math/tex">x</script> is near to <script type="math/tex">f(x)</script> and according to the Collage Theorem <script type="math/tex">x</script> and <script type="math/tex">x_0</script> will be near too.</p>

<p>Thus, we will, independently for each <script type="math/tex">l</script>, construct lots of contractions from each <script type="math/tex">D_{k}</script> to <script type="math/tex">R_l</script> and select the best one. We will show all the nitty-gritty details in the next section.</p>

<h1 id="implementation">Implementation</h1>

<p>In each section, I will copy the interesting snippets of code but you can find the whole script <a href="https://github.com/pvigier/fractal-image-compression/blob/master/compression.py">here</a>.</p>

<h2 id="segmentations">Segmentations</h2>

<p>I keep things really simple. The source blocks and the destination blocks segment the image as a grid, as on the image above.</p>

<p>The size of the blocks are powers of two as it makes things easier. The source blocks are 8 by 8 while the destination blocks are 4 by 4.</p>

<p>There exist more advanced schemes for segmentation. For instance, we can use a quadtree to segment more the areas with lots of details.</p>

<h2 id="transformations">Transformations</h2>

<p>In this section, we will show how to construct the contractions from <script type="math/tex">D_{k}</script> to <script type="math/tex">R_l</script>.</p>

<p>Remember that we want to generate a mapping <script type="math/tex">f_l</script> such that <script type="math/tex">f(x_{D_k})</script> is near to <script type="math/tex">x_{R_l}</script>. So, the more mappings we generate, the more likely we are to find a good one.</p>

<p>However, the quality of the compression depends on the number of bits necessary to save <script type="math/tex">f_l</script>. So if we have a set of functions that is too large, the compression will be bad. There is a tradeoff to find.</p>

<p>I chose that <script type="math/tex">f_l</script> will have the following form:
<script type="math/tex">f_l(x_{D_k}) = s \times rotate_{\theta}(flip_d(reduce(x_{D_k}))) + b</script></p>

<p>where <script type="math/tex">reduce</script> is a function to go from 8 by 8 blocks to 4 by 4 blocks, <script type="math/tex">flip</script> and <script type="math/tex">rotate</script> are affine transformations, <script type="math/tex">s</script> changes the contrast and <script type="math/tex">b</script> the brightness.</p>

<p>The function <code class="highlighter-rouge">reduce</code> reduces the size of an image by averaging neighborhoods:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">factor</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">factor</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">factor</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">factor</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>The function <code class="highlighter-rouge">rotate</code> simply rotates by the given angle the image:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">reshape</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<p>In order to preserve the shape of the image, the angle <script type="math/tex">\theta</script> will be in <script type="math/tex">\{0^{\circ}, 90^{\circ}, 180^{\circ}, 270^{\circ}\}</script>.</p>

<p>The function <code class="highlighter-rouge">flip</code> flips the image if <code class="highlighter-rouge">direction</code> is equal to -1 and does not if it is equal to 1:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">img</span><span class="p">[::</span><span class="n">direction</span><span class="p">,:]</span>
</code></pre></div></div>

<p>The whole transformation is done by the function <code class="highlighter-rouge">apply_transformation</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">contrast</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">brightness</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">contrast</span><span class="o">*</span><span class="n">rotate</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">direction</span><span class="p">),</span> <span class="n">angle</span><span class="p">)</span> <span class="o">+</span> <span class="n">brightness</span>
</code></pre></div></div>

<p>We need 1 bit to remember if we flip or not and 2 bits for the angle of rotation. Moreover, if we save <script type="math/tex">s</script> and <script type="math/tex">b</script> using 8 bits each then we need only 11 bits in total to save the transformation.</p>

<p>Moreover, we should check that these functions are contractions. The proof is a bit tedious and we do not care much. Maybe I will add it in appendix later.</p>

<h2 id="compression">Compression</h2>

<p>The algorithm for compression is simple. First we generate all possible affine transformations of all source blocks using the function <code class="highlighter-rouge">generate_all_transformed_blocks</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_all_transformed_blocks</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">source_size</span> <span class="o">//</span> <span class="n">destination_size</span>
    <span class="n">transformed_blocks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">source_size</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">source_size</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># Extract the source block and reduce it to the shape of a destination block</span>
            <span class="n">S</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">step</span><span class="p">:</span><span class="n">k</span><span class="o">*</span><span class="n">step</span><span class="o">+</span><span class="n">source_size</span><span class="p">,</span><span class="n">l</span><span class="o">*</span><span class="n">step</span><span class="p">:</span><span class="n">l</span><span class="o">*</span><span class="n">step</span><span class="o">+</span><span class="n">source_size</span><span class="p">],</span> <span class="n">factor</span><span class="p">)</span>
            <span class="c"># Generate all possible transformed blocks</span>
            <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="n">transformed_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">apply_transform</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">angle</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">transformed_blocks</span>
</code></pre></div></div>

<p>Then for each destination block, we try all the previously generated transformed source blocks. For each we optimize the contrast and the brightness using the method <code class="highlighter-rouge">find_contrast_and_brightness2</code> and if the tested transformation is the best we have seen so far, we saved it:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
    <span class="n">transformations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">transformed_blocks</span> <span class="o">=</span> <span class="n">generate_all_transformed_blocks</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">destination_size</span><span class="p">):</span>
        <span class="n">transformations</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">destination_size</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">transformations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">min_d</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
            <span class="c"># Extract the destination block</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">destination_size</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">destination_size</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">destination_size</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">destination_size</span><span class="p">]</span>
            <span class="c"># Test all possible transformations and take the best one</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">transformed_blocks</span><span class="p">:</span>
                <span class="n">contrast</span><span class="p">,</span> <span class="n">brightness</span> <span class="o">=</span> <span class="n">find_contrast_and_brightness2</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">contrast</span><span class="o">*</span><span class="n">S</span> <span class="o">+</span> <span class="n">brightness</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">D</span> <span class="o">-</span> <span class="n">S</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">min_d</span><span class="p">:</span>
                    <span class="n">min_d</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">transformations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">contrast</span><span class="p">,</span> <span class="n">brightness</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transformations</span>
</code></pre></div></div>

<p>To find the best contrast and brightness, the method <code class="highlighter-rouge">find_contrast_and_brightness2</code> simply solves a least square problem:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_contrast_and_brightness2</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
    <span class="c"># Fit the contrast and the brightness</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">S</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">size</span><span class="p">,))</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="decompression">Decompression</h2>

<p>The decompression algorithm is even simpler. We just start from a completely random image and then we apply the contraction <script type="math/tex">f</script> several times:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decompress</span><span class="p">(</span><span class="n">transformations</span><span class="p">,</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">nb_iter</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">source_size</span> <span class="o">//</span> <span class="n">destination_size</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">transformations</span><span class="p">)</span> <span class="o">*</span> <span class="n">destination_size</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">transformations</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">destination_size</span>
    <span class="n">iterations</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))]</span>
    <span class="n">cur_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_iter</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">i_iter</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transformations</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transformations</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="c"># Apply transform</span>
                <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">flip</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">contrast</span><span class="p">,</span> <span class="n">brightness</span> <span class="o">=</span> <span class="n">transformations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="n">S</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">iterations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="o">*</span><span class="n">step</span><span class="p">:</span><span class="n">k</span><span class="o">*</span><span class="n">step</span><span class="o">+</span><span class="n">source_size</span><span class="p">,</span><span class="n">l</span><span class="o">*</span><span class="n">step</span><span class="p">:</span><span class="n">l</span><span class="o">*</span><span class="n">step</span><span class="o">+</span><span class="n">source_size</span><span class="p">],</span> <span class="n">factor</span><span class="p">)</span>
                <span class="n">D</span> <span class="o">=</span> <span class="n">apply_transformation</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">flip</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">contrast</span><span class="p">,</span> <span class="n">brightness</span><span class="p">)</span>
                <span class="n">cur_img</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">destination_size</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">destination_size</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">destination_size</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">destination_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span>
        <span class="n">iterations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_img</span><span class="p">)</span>
        <span class="n">cur_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">iterations</span>
</code></pre></div></div>

<p>It works because the contraction has a unique fixed point and whatever initial image we choose, we will tend to it.</p>

<p>I think, it is time for a little example. We will try to compress and decompress this image of a monkey:</p>

<p><img src="/media/img/fractal/monkey.png" alt="Monkey" class="center-image modal-image" /></p>

<p>The function <code class="highlighter-rouge">test_greyscale</code> loads the image compresses it, decompresses and shows each iteration of the decompression:</p>

<p><img src="/media/img/fractal/monkey_64_4_8.png" alt="Decompression of a greyscale image" class="center-image modal-image" /></p>

<p>Not bad for this very simple implementation!</p>

<h2 id="rgb-images">RGB images</h2>

<p>A very naive solution to compress RGB images is to compress the three channels separately:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compress_rgb</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
    <span class="n">img_r</span><span class="p">,</span> <span class="n">img_g</span><span class="p">,</span> <span class="n">img_b</span> <span class="o">=</span> <span class="n">extract_rgb</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">compress</span><span class="p">(</span><span class="n">img_r</span><span class="p">,</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">),</span> \
        <span class="n">compress</span><span class="p">(</span><span class="n">img_g</span><span class="p">,</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">),</span> \
        <span class="n">compress</span><span class="p">(</span><span class="n">img_b</span><span class="p">,</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">)]</span>
</code></pre></div></div>

<p>And to decompress, we just decompress the three channels separately and then we assemble the three channels:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decompress_rgb</span><span class="p">(</span><span class="n">transformations</span><span class="p">,</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">nb_iter</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="n">img_r</span> <span class="o">=</span> <span class="n">decompress</span><span class="p">(</span><span class="n">transformations</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">nb_iter</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">img_g</span> <span class="o">=</span> <span class="n">decompress</span><span class="p">(</span><span class="n">transformations</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">nb_iter</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">img_b</span> <span class="o">=</span> <span class="n">decompress</span><span class="p">(</span><span class="n">transformations</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">source_size</span><span class="p">,</span> <span class="n">destination_size</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">nb_iter</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">assemble_rbg</span><span class="p">(</span><span class="n">img_r</span><span class="p">,</span> <span class="n">img_g</span><span class="p">,</span> <span class="n">img_b</span><span class="p">)</span>
</code></pre></div></div>

<p>Another very simple solution would be to use the same contraction for the three channels as they often are very similar.</p>

<p>If you would like to see it works, you can run the function <code class="highlighter-rouge">test_rgb</code>:</p>

<p><img src="/media/img/fractal/lena_64_4_8.png" alt="Decompression of a RGB image" class="center-image modal-image" /></p>

<p>There are some artifacts. This method is maybe too naive to give good results.</p>

<h1 id="to-go-further">To go further</h1>

<p>If you would like to learn more about fractal image compression, I can suggest you to read <a href="https://spie.org/publications/book/353798?print=2&amp;SSO=1">Fractal and Wavelet Image Compression Techniques</a> by Stephen Welstead. It is easy to read and explains more advanced techniques.</p>

<p>If you have any suggestion or question, do not hesitate to leave a comment below.</p>

    
	<p>Tags: <span class="label label-primary"><a href="/tag/math">math</a></span> <span class="label label-primary"><a href="/tag/python">python</a></span> </p>
	
</div><!-- /.blog-post -->


<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://pvigier-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div><!-- /.blog-main -->
<div class="col-sm-3 col-sm-offset-1 blog-sidebar">
	<div class="sidebar-module">
        <h4>Tags</h4>
        <ol class="list-unstyled">
		
			<li><a href="/tag/math">math (3)</a></li>
		
			<li><a href="/tag/python">python (6)</a></li>
		
			<li><a href="/tag/cpp">cpp (4)</a></li>
		
			<li><a href="/tag/pcg">pcg (3)</a></li>
		
			<li><a href="/tag/simulopolis">simulopolis (4)</a></li>
		
			<li><a href="/tag/linux">linux (1)</a></li>
		
			<li><a href="/tag/geometry">geometry (1)</a></li>
		
        </ol>
    </div>
    <div class="sidebar-module">
        <h4>Archives</h4>
        <ol class="list-unstyled">
		
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
			<li id="yNovember 2018"><a href="/2018/11">November 2018 (3)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
			<li id="yOctober 2018"><a href="/2018/10">October 2018 (3)</a></li>
				
            
        
            
            
            
            
			<li id="yJune 2018"><a href="/2018/06">June 2018 (1)</a></li>
				
            
        
            
            
            
            
			<li id="yMay 2018"><a href="/2018/05">May 2018 (1)</a></li>
				
            
        
            
            
            
            
        
            
            
            
            
			<li id="yFebruary 2018"><a href="/2018/02">February 2018 (2)</a></li>
				
            
        
            
            
            
            
			<li id="yAugust 2017"><a href="/2017/08">August 2017 (1)</a></li>
				
            
        
            
            
            
            
			<li id="yJuly 2017"><a href="/2017/07">July 2017 (1)</a></li>
				
            
        
            
            
            
            
			<li id="yFebruary 2017"><a href="/2017/02">February 2017 (1)</a></li>
				
            
        
        </ol>
    </div>
    <div class="sidebar-module">
        <h4>Follow me</h4>
        <ol class="list-unstyled">
            <li><a href="https://github.com/pvigier">GitHub</a></li>
            <li><a href="https://pvigier.itch.io/">itch.io</a></li>
            <li><a href="https://twitter.com/PierreVigier">Twitter</a></li>
            <li><a href="/rss.xml">RSS</a></li>
        </ol>
    </div>
</div><!-- /.blog-sidebar -->

            </div><!-- /.row -->
        </div><!-- /.container -->

        <footer class="blog-footer">
            <p>Powered by <a href="http://getbootstrap.com">Bootstrap</a> and <a href="http://jekyllrb.com">Jekyll</a>.</p>
            <p>
                <a href="#">Back to top</a>
            </p>
        </footer>
        <!-- Javascript -->
        <!-- jQuery -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
        <!-- Bootstrap -->
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
        <!-- MathJax -->
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
        <!-- Analytics -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-30902264-4', 'auto');
        ga('send', 'pageview');
        </script>
        <!-- Modal images -->
        <script src="/media/js/modal.js"></script>
    </body>
</html>
